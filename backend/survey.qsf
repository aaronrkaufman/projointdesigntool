{"meta":{"httpStatus":"200 - OK","requestId":"5ea56ee2-e0f5-4833-a750-b7a418acab3e"},"result":{"SurveyEntry":{"SurveyID":"SV_0IZdEq5rOGs2DGu","SurveyName":"export survey","SurveyDescription":null,"SurveyOwnerID":"UR_8DkyPzrgfkKf1Ma","SurveyBrandID":"nyu","DivisionID":null,"SurveyLanguage":"AR","SurveyActiveResponseSet":"RS_bw5sVeqmQg6y246","SurveyStatus":"Inactive","SurveyStartDate":"0000-00-00 00:00:00","SurveyExpirationDate":"0000-00-00 00:00:00","SurveyCreationDate":"2023-11-27 06:32:06","CreatorID":"UR_8DkyPzrgfkKf1Ma","LastModified":"2023-11-27 06:32:20","LastAccessed":"0000-00-00 00:00:00","LastActivated":"0000-00-00 00:00:00","Deleted":null},"SurveyElements":[{"SurveyID":"SV_0IZdEq5rOGs2DGu","Element":"BL","PrimaryAttribute":"Survey Blocks","SecondaryAttribute":null,"TertiaryAttribute":null,"Payload":[{"Type":"Default","Description":"Default Question Block","ID":"BL_5okifeqPVEV66l8"},{"Type":"Trash","Description":"Trash / Unused Questions","ID":"BL_eg1tmAAtQANq2Fw"},{"Type":"Standard","SubType":"","Description":"Block","ID":"BL_5bRrkNwrLu9m1kq","BlockElements":[{"Type":"Question","QuestionID":"QID1"}]},{"Type":"Standard","SubType":"","Description":"Block","ID":"BL_ba2WNcVaFPkvLuK","BlockElements":[{"Type":"Question","QuestionID":"QID2"}]},{"Type":"Standard","SubType":"","Description":"Block","ID":"BL_exnvY3ZJdZ9jmbY","BlockElements":[{"Type":"Question","QuestionID":"QID3"}]},{"Type":"Standard","SubType":"","Description":"Block","ID":"BL_dnVT9ZN01T849H8","BlockElements":[{"Type":"Question","QuestionID":"QID4"}]},{"Type":"Standard","SubType":"","Description":"Block","ID":"BL_1MntMq5VWKrvoJo","BlockElements":[{"Type":"Question","QuestionID":"QID5"}]}]},{"SurveyID":"SV_0IZdEq5rOGs2DGu","Element":"FL","PrimaryAttribute":"Survey Flow","SecondaryAttribute":null,"TertiaryAttribute":null,"Payload":{"Flow":[{"ID":"BL_5okifeqPVEV66l8","Type":"Block","FlowID":"FL_2"},{"ID":"BL_5bRrkNwrLu9m1kq","Type":"Standard","FlowID":"FL_3"},{"ID":"BL_ba2WNcVaFPkvLuK","Type":"Standard","FlowID":"FL_4"},{"ID":"BL_exnvY3ZJdZ9jmbY","Type":"Standard","FlowID":"FL_5"},{"ID":"BL_dnVT9ZN01T849H8","Type":"Standard","FlowID":"FL_6"},{"ID":"BL_1MntMq5VWKrvoJo","Type":"Standard","FlowID":"FL_7"}],"Properties":{"Count":7},"FlowID":"FL_1","Type":"Root"}},{"SurveyID":"SV_0IZdEq5rOGs2DGu","Element":"PL","PrimaryAttribute":"Preview Link","SecondaryAttribute":null,"TertiaryAttribute":null,"Payload":{"PreviewType":"Brand","PreviewID":"39f88a22-17db-4cd7-9927-c451002ba68d"}},{"SurveyID":"SV_0IZdEq5rOGs2DGu","Element":"SO","PrimaryAttribute":"Survey Options","SecondaryAttribute":null,"TertiaryAttribute":null,"Payload":{"BackButton":"false","SaveAndContinue":"true","SurveyProtection":"PublicSurvey","BallotBoxStuffingPrevention":"false","NoIndex":"Yes","SecureResponseFiles":"true","SurveyExpiration":"None","SurveyTermination":"DefaultMessage","Header":"","Footer":"","ProgressBarDisplay":"None","PartialData":"+1 week","ValidationMessage":"","PreviousButton":"","NextButton":"","SurveyTitle":"Qualtrics Survey | Qualtrics Experience Management","SkinLibrary":"nyu","SkinType":"templated","Skin":{"brandingId":"2282410469","templateId":"*base","overrides":null},"NewScoring":1,"SurveyMetaDescription":"The most powerful, simple and trusted way to gather experience data. Start your journey to experience management and try a free account today."}},{"SurveyID":"SV_0IZdEq5rOGs2DGu","Element":"SQ","PrimaryAttribute":"QID1","SecondaryAttribute":null,"TertiaryAttribute":null,"Payload":{"QuestionText":"<span>Question 1</span>\n<br /><br />\n<span>Please carefully review the options detailed below, then please answer the questions.</span>\n<br/>\n<br/>\n<span>Which of these choices do you prefer?</span>\n<br />\n<div>\n<br />\n<table class=\"UserTable\">\n<tbody>\n<tr>\n<td>&nbsp;</td>\n<td style=\"text-align: center;\">\n<strong>Choice 1</strong></td>\n<td style=\"text-align: center;\">\n<strong>Choice 2</strong></td>\n</tr>\n<tr>\n<td style='text-align: center;'><strong>${e://Field/F-1-1}</strong></td>\n<td style='text-align: center;'>${e://Field/F-1-1-1}</td>\n<td style='text-align: center;'>${e://Field/F-1-2-1}</td>\n</tr><tr>\n<td style='text-align: center;'><strong>${e://Field/F-1-2}</strong></td>\n<td style='text-align: center;'>${e://Field/F-1-1-2}</td>\n<td style='text-align: center;'>${e://Field/F-1-2-2}</td>\n</tr></tbody>\n</table>\n</div>","QuestionType":"MC","Selector":"SAVR","Choices":{"1":{"Display":"Profile 1"},"2":{"Display":"Profile 2"}},"QuestionJS":"Qualtrics.SurveyEngine.addOnload(function() {\n\t// Code to randomly generate conjoint profiles in a Qualtrics survey\n\n// Terminology clarification: \n// Task = Set of choices presented to respondent in a single screen (i.e. pair of candidates)\n// Profile = Single list of attributes in a given task (i.e. candidate)\n// Attribute = Category characterized by a set of levels (i.e. education level)\n// Level = Value that an attribute can take in a particular choice task (i.e. \"no formal education\")\n\n// Attributes and Levels stored in a 2-dimensional Array \n\n/* Randomize array in-place using Durstenfeld shuffle algorithm */\nfunction shuffleArray(array) {\n    for (var i = array.length - 1; i > 0; i--) {\n        var j = Math.floor(Math.random() * (i + 1));\n        var temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n    return(array);\n}\n\n// Function to generate weighted random numbers\nfunction weighted_randomize(prob_array, at_key)\n{\n\tvar prob_list = prob_array[at_key];\n\t\n\t// Create an array containing cutpoints for randomization\n\tvar cumul_prob = new Array(prob_list.length);\n\tvar cumulative = 0.0;\n\tfor (var i=0;  i < prob_list.length; i++){\n\t\tcumul_prob[i] = cumulative;\n\t\tcumulative = cumulative + parseFloat(prob_list[i]);\n\t}\n\n\t// Generate a uniform random floating point value between 0.0 and 1.0\n\tvar unif_rand = Math.random();\n\n\t// Figure out which integer should be returned\n\tvar outInt = 0;\n\tfor (var k = 0; k < cumul_prob.length; k++){\n\t\tif (cumul_prob[k] <= unif_rand){\n\t\t\toutInt = k + 1;\n\t\t}\n\t}\n\n\treturn(outInt);\n\n}\n                    \n\n\tvar featurearray = {\"check\" : [\"adding\",\"checking\",\"maybe working\"],\"check2\" : [\"checking1\",\"checking2\"]};\n\n\n\tvar restrictionarray = [];\n\n\n\tvar probabilityarray = {};\n\n\t// Indicator for whether weighted randomization should be enabled or not\n\tvar weighted = 0;\n\n\t// K = Number of tasks displayed to the respondent\n\tvar K = 5;\n\n\t// N = Number of profiles displayed in each task\n\tvar N = 2;\n\n\t// num_attributes = Number of Attributes in the Array\n\tvar num_attributes = featurearray.length;\n\n\t// Should duplicate profiles be rejected?\n\tvar noDuplicateProfiles = 0;\n\n\tvar attrconstraintarray = [];\n// Re-randomize the featurearray\n\n// Place the featurearray keys into a new array\nvar featureArrayKeys = Object.keys(featurearray);\n\n// If order randomization constraints exist, drop all of the non-free attributes\nif (attrconstraintarray.length != 0){\n\tfor (const constraints of attrconstraintarray){\n\t\tif (constraints.length > 1){\n\t\t\tfor (var p = 1; p < constraints.length; p++){\n\t\t\t\tif (featureArrayKeys.includes(constraints[p])){\n\t\t\t\t\tvar remkey = featureArrayKeys.indexOf(constraints[p]);\n                    featureArrayKeys.splice(remkey, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} \n\n// Re-randomize the featurearray keys\nfeatureArrayKeys = shuffleArray(featureArrayKeys);\n\n// Re-insert the non-free attributes constrained by attrconstraintarray\nif (attrconstraintarray.length != 0){\n\tfor (const constraints of attrconstraintarray){\n\t\tif (constraints.length > 1){\n\t\t\tvar insertloc = constraints[0];\n\t\t\tif (featureArrayKeys.includes(insertloc)){\n\t\t\t\tvar insert_block = [];\n\t\t\t\tfor (var p = 1; p < constraints.length; p++){\n          insert_block.push(constraints[p]);\n\t\t\t\t}\n\t\t\t\tvar begin_index = featureArrayKeys.indexOf(insertloc);\n\t\t\t\tfeatureArrayKeys.splice(begin_index+1, 0, ...insert_block);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// Re-generate the new featurearray - label it featureArrayNew\nvar featureArrayNew = {};\nfor (var h = 0; h < featureArrayKeys.length; h++){\n    featureArrayNew[featureArrayKeys[h]] = featurearray[featureArrayKeys[h]];        \n}\n\n\n// Initialize the array returned to the user\n// Naming Convention\n// Level Name: F-[task number]-[profile number]-[attribute number]\n// Attribute Name: F-[task number]-[attribute number]\n// Example: F-1-3-2, Returns the level corresponding to Task 1, Profile 3, Attribute 2 \n// F-3-3, Returns the attribute name corresponding to Task 3, Attribute 3\n\nvar returnarray = {};\n\n// For each task p\nfor(var p = 1; p <= K; p++){\n\n\t// For each profile i\n\tfor(var i = 1; i <= N; i++){\n\n\t\t// Repeat until non-restricted profile generated\n\t\tvar complete = false;\n\n\t\twhile (complete == false){\n\n\t\t\t// Create a count for attributes to be incremented in the next loop\n\t\t\tvar attr = 0;\n\t\t\t\n\t\t\t// Create a dictionary to hold profile's attributes\n\t\t\tvar profile_dict = {};\n\n\t\t\t// For each attribute attribute and level array levels in task p\n\t\t\tfor(var q = 0; q < featureArrayKeys.length; q++){\n\t\t\t\t// Get Attribute name\n\t\t\t\tvar attr_name = featureArrayKeys[q];\n\t\t\t\t\t\n\t\t\t\t// Increment attribute count\n\t\t\t\tattr = attr + 1;\n\t\n\t\t\t\t// Create key for attribute name\n\t\t\t\tvar attr_key = \"F-\" + p + \"-\" + attr;\n\t\n                // Store attribute name in returnarray\n                returnarray[attr_key] = attr_name;\n\n\t\t\t\t// Get length of levels array\n\t\t\t\tvar num_levels = featureArrayNew[attr_name].length;\n\n\t\t\t\t// Randomly select one of the level indices\n\t\t\t\tif (weighted == 1){\n\t\t\t\t\tvar level_index = weighted_randomize(probabilityarray, attr_name) - 1;\n\n\t\t\t\t}else{\n\t\t\t\t\tvar level_index = Math.floor(Math.random() * num_levels);\n\t\t\t\t}\t\n\n\t\t\t\t// Pull out the selected level\n\t\t\t\tvar chosen_level = featureArrayNew[attr_name][level_index];\n\t\t\t\t\n\t\t\t\t// Store selected level in profileDict\n\t\t\t\tprofile_dict[attr_name] = chosen_level;\n\t\n\t\t\t\t// Create key for level in returnarray\n\t\t\t\tvar level_key = \"F-\" + p + \"-\" + i + \"-\" + attr;\n\t\n\t\t\t\t// Store selected level in returnarray\n\t\t\t\treturnarray[level_key] = chosen_level;\n\n\t\t\t}\n\n            var clear = true;\n            \n            // Cycle through restrictions to confirm/reject profile\n            if (restrictionarray.length != 0){\n                for (var v = 0; v < restrictionarray.length; v++){\n                    var falsevar = 1;\n                    for (var mp = 0; mp < restrictionarray[v].length; mp++){\n                        if (profile_dict[restrictionarray[v][mp][0]] == restrictionarray[v][mp][1]){\n                            falsevar = falsevar*1;\n                        }else{\n                            falsevar = falsevar*0;\n                        }\t\t\t\t\t\t\t\n                    }\n                    if (falsevar == 1){\n                        clear = false;\n                    }\n                }\n            }\n                            \n            // If we're throwing out duplicates\n            if (noDuplicateProfiles == true){\n                // Cycle through all previous profiles to confirm no identical profiles\n                if (i > 1){    \n                    // For each previous profile\n                    for(var z = 1; z < i; z++){\n    \t\t\t\t\t\n                        // Start by assuming it's the same\n                        var identical = true;\n    \t\t\t\t\t\n                        // Create a count for attributes to be incremented in the next loop\n                        var attrTemp = 0;\n    \t\t\t\t\t\n                        // For each attribute attribute and level array levels in task p\n                        for(var qz = 0; qz < featureArrayKeys.length; qz++){\n    \t\t\t\t\t\t\n                            // Increment attribute count\n                            attrTemp = attrTemp + 1;\n    \n                            // Create keys \n                            var level_key_profile = \"F-\" + p + \"-\" + i + \"-\" + attrTemp;\n                            var level_key_check = \"F-\" + p + \"-\" + z + \"-\" + attrTemp;\n    \t\t\t\t\t\t\n                            // If attributes are different, declare not identical\n                            if (returnarray[level_key_profile] != returnarray[level_key_check]){\n                                identical = false;\n                            }\n                        }\n                        // If we detect an identical profile, reject\n                        if (identical == true){\n                            clear = false;\n                        }\n                    }                \n                }\n            }\n            complete = clear;\n        }\n    }\n}\n                            \n// Write returnarray to Qualtrics\n\nvar returnarrayKeys = Object.keys(returnarray);\n\nfor (var pr = 0; pr < returnarrayKeys.length; pr++){\n       Qualtrics.SurveyEngine.setEmbeddedData(returnarrayKeys[pr], returnarray[returnarrayKeys[pr]]); \n}\n});\nQualtrics.SurveyEngine.addOnReady(function() {\n\t/* Place your JavaScript here to run when the page is fully displayed */\n});\nQualtrics.SurveyEngine.addOnUnload(function() {\n\t/* Place your JavaScript here to run when the page is unloaded */\n});","DataExportTag":"Q1","QuestionID":"QID1"}},{"SurveyID":"SV_0IZdEq5rOGs2DGu","Element":"SQ","PrimaryAttribute":"QID2","SecondaryAttribute":null,"TertiaryAttribute":null,"Payload":{"QuestionText":"<span>Question 2</span>\n<br /><br />\n<span>Please carefully review the options detailed below, then please answer the questions.</span>\n<br/>\n<br/>\n<span>Which of these choices do you prefer?</span>\n<br />\n<div>\n<br />\n<table class=\"UserTable\">\n<tbody>\n<tr>\n<td>&nbsp;</td>\n<td style=\"text-align: center;\">\n<strong>Choice 1</strong></td>\n<td style=\"text-align: center;\">\n<strong>Choice 2</strong></td>\n</tr>\n<tr>\n<td style='text-align: center;'><strong>${e://Field/F-2-1}</strong></td>\n<td style='text-align: center;'>${e://Field/F-2-1-1}</td>\n<td style='text-align: center;'>${e://Field/F-2-2-1}</td>\n</tr><tr>\n<td style='text-align: center;'><strong>${e://Field/F-2-2}</strong></td>\n<td style='text-align: center;'>${e://Field/F-2-1-2}</td>\n<td style='text-align: center;'>${e://Field/F-2-2-2}</td>\n</tr></tbody>\n</table>\n</div>","QuestionType":"MC","Selector":"SAVR","Choices":{"1":{"Display":"Profile 1"},"2":{"Display":"Profile 2"}},"QuestionJS":"Qualtrics.SurveyEngine.addOnload(function() {\n\t// Code to randomly generate conjoint profiles in a Qualtrics survey\n\n// Terminology clarification: \n// Task = Set of choices presented to respondent in a single screen (i.e. pair of candidates)\n// Profile = Single list of attributes in a given task (i.e. candidate)\n// Attribute = Category characterized by a set of levels (i.e. education level)\n// Level = Value that an attribute can take in a particular choice task (i.e. \"no formal education\")\n\n// Attributes and Levels stored in a 2-dimensional Array \n\n/* Randomize array in-place using Durstenfeld shuffle algorithm */\nfunction shuffleArray(array) {\n    for (var i = array.length - 1; i > 0; i--) {\n        var j = Math.floor(Math.random() * (i + 1));\n        var temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n    return(array);\n}\n\n// Function to generate weighted random numbers\nfunction weighted_randomize(prob_array, at_key)\n{\n\tvar prob_list = prob_array[at_key];\n\t\n\t// Create an array containing cutpoints for randomization\n\tvar cumul_prob = new Array(prob_list.length);\n\tvar cumulative = 0.0;\n\tfor (var i=0;  i < prob_list.length; i++){\n\t\tcumul_prob[i] = cumulative;\n\t\tcumulative = cumulative + parseFloat(prob_list[i]);\n\t}\n\n\t// Generate a uniform random floating point value between 0.0 and 1.0\n\tvar unif_rand = Math.random();\n\n\t// Figure out which integer should be returned\n\tvar outInt = 0;\n\tfor (var k = 0; k < cumul_prob.length; k++){\n\t\tif (cumul_prob[k] <= unif_rand){\n\t\t\toutInt = k + 1;\n\t\t}\n\t}\n\n\treturn(outInt);\n\n}\n                    \n\n\tvar featurearray = {\"check\" : [\"adding\",\"checking\",\"maybe working\"],\"check2\" : [\"checking1\",\"checking2\"]};\n\n\n\tvar restrictionarray = [];\n\n\n\tvar probabilityarray = {};\n\n\t// Indicator for whether weighted randomization should be enabled or not\n\tvar weighted = 0;\n\n\t// K = Number of tasks displayed to the respondent\n\tvar K = 5;\n\n\t// N = Number of profiles displayed in each task\n\tvar N = 2;\n\n\t// num_attributes = Number of Attributes in the Array\n\tvar num_attributes = featurearray.length;\n\n\t// Should duplicate profiles be rejected?\n\tvar noDuplicateProfiles = 0;\n\n\tvar attrconstraintarray = [];\n// Re-randomize the featurearray\n\n// Place the featurearray keys into a new array\nvar featureArrayKeys = Object.keys(featurearray);\n\n// If order randomization constraints exist, drop all of the non-free attributes\nif (attrconstraintarray.length != 0){\n\tfor (const constraints of attrconstraintarray){\n\t\tif (constraints.length > 1){\n\t\t\tfor (var p = 1; p < constraints.length; p++){\n\t\t\t\tif (featureArrayKeys.includes(constraints[p])){\n\t\t\t\t\tvar remkey = featureArrayKeys.indexOf(constraints[p]);\n                    featureArrayKeys.splice(remkey, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} \n\n// Re-randomize the featurearray keys\nfeatureArrayKeys = shuffleArray(featureArrayKeys);\n\n// Re-insert the non-free attributes constrained by attrconstraintarray\nif (attrconstraintarray.length != 0){\n\tfor (const constraints of attrconstraintarray){\n\t\tif (constraints.length > 1){\n\t\t\tvar insertloc = constraints[0];\n\t\t\tif (featureArrayKeys.includes(insertloc)){\n\t\t\t\tvar insert_block = [];\n\t\t\t\tfor (var p = 1; p < constraints.length; p++){\n          insert_block.push(constraints[p]);\n\t\t\t\t}\n\t\t\t\tvar begin_index = featureArrayKeys.indexOf(insertloc);\n\t\t\t\tfeatureArrayKeys.splice(begin_index+1, 0, ...insert_block);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// Re-generate the new featurearray - label it featureArrayNew\nvar featureArrayNew = {};\nfor (var h = 0; h < featureArrayKeys.length; h++){\n    featureArrayNew[featureArrayKeys[h]] = featurearray[featureArrayKeys[h]];        \n}\n\n\n// Initialize the array returned to the user\n// Naming Convention\n// Level Name: F-[task number]-[profile number]-[attribute number]\n// Attribute Name: F-[task number]-[attribute number]\n// Example: F-1-3-2, Returns the level corresponding to Task 1, Profile 3, Attribute 2 \n// F-3-3, Returns the attribute name corresponding to Task 3, Attribute 3\n\nvar returnarray = {};\n\n// For each task p\nfor(var p = 1; p <= K; p++){\n\n\t// For each profile i\n\tfor(var i = 1; i <= N; i++){\n\n\t\t// Repeat until non-restricted profile generated\n\t\tvar complete = false;\n\n\t\twhile (complete == false){\n\n\t\t\t// Create a count for attributes to be incremented in the next loop\n\t\t\tvar attr = 0;\n\t\t\t\n\t\t\t// Create a dictionary to hold profile's attributes\n\t\t\tvar profile_dict = {};\n\n\t\t\t// For each attribute attribute and level array levels in task p\n\t\t\tfor(var q = 0; q < featureArrayKeys.length; q++){\n\t\t\t\t// Get Attribute name\n\t\t\t\tvar attr_name = featureArrayKeys[q];\n\t\t\t\t\t\n\t\t\t\t// Increment attribute count\n\t\t\t\tattr = attr + 1;\n\t\n\t\t\t\t// Create key for attribute name\n\t\t\t\tvar attr_key = \"F-\" + p + \"-\" + attr;\n\t\n                // Store attribute name in returnarray\n                returnarray[attr_key] = attr_name;\n\n\t\t\t\t// Get length of levels array\n\t\t\t\tvar num_levels = featureArrayNew[attr_name].length;\n\n\t\t\t\t// Randomly select one of the level indices\n\t\t\t\tif (weighted == 1){\n\t\t\t\t\tvar level_index = weighted_randomize(probabilityarray, attr_name) - 1;\n\n\t\t\t\t}else{\n\t\t\t\t\tvar level_index = Math.floor(Math.random() * num_levels);\n\t\t\t\t}\t\n\n\t\t\t\t// Pull out the selected level\n\t\t\t\tvar chosen_level = featureArrayNew[attr_name][level_index];\n\t\t\t\t\n\t\t\t\t// Store selected level in profileDict\n\t\t\t\tprofile_dict[attr_name] = chosen_level;\n\t\n\t\t\t\t// Create key for level in returnarray\n\t\t\t\tvar level_key = \"F-\" + p + \"-\" + i + \"-\" + attr;\n\t\n\t\t\t\t// Store selected level in returnarray\n\t\t\t\treturnarray[level_key] = chosen_level;\n\n\t\t\t}\n\n            var clear = true;\n            \n            // Cycle through restrictions to confirm/reject profile\n            if (restrictionarray.length != 0){\n                for (var v = 0; v < restrictionarray.length; v++){\n                    var falsevar = 1;\n                    for (var mp = 0; mp < restrictionarray[v].length; mp++){\n                        if (profile_dict[restrictionarray[v][mp][0]] == restrictionarray[v][mp][1]){\n                            falsevar = falsevar*1;\n                        }else{\n                            falsevar = falsevar*0;\n                        }\t\t\t\t\t\t\t\n                    }\n                    if (falsevar == 1){\n                        clear = false;\n                    }\n                }\n            }\n                            \n            // If we're throwing out duplicates\n            if (noDuplicateProfiles == true){\n                // Cycle through all previous profiles to confirm no identical profiles\n                if (i > 1){    \n                    // For each previous profile\n                    for(var z = 1; z < i; z++){\n    \t\t\t\t\t\n                        // Start by assuming it's the same\n                        var identical = true;\n    \t\t\t\t\t\n                        // Create a count for attributes to be incremented in the next loop\n                        var attrTemp = 0;\n    \t\t\t\t\t\n                        // For each attribute attribute and level array levels in task p\n                        for(var qz = 0; qz < featureArrayKeys.length; qz++){\n    \t\t\t\t\t\t\n                            // Increment attribute count\n                            attrTemp = attrTemp + 1;\n    \n                            // Create keys \n                            var level_key_profile = \"F-\" + p + \"-\" + i + \"-\" + attrTemp;\n                            var level_key_check = \"F-\" + p + \"-\" + z + \"-\" + attrTemp;\n    \t\t\t\t\t\t\n                            // If attributes are different, declare not identical\n                            if (returnarray[level_key_profile] != returnarray[level_key_check]){\n                                identical = false;\n                            }\n                        }\n                        // If we detect an identical profile, reject\n                        if (identical == true){\n                            clear = false;\n                        }\n                    }                \n                }\n            }\n            complete = clear;\n        }\n    }\n}\n                            \n// Write returnarray to Qualtrics\n\nvar returnarrayKeys = Object.keys(returnarray);\n\nfor (var pr = 0; pr < returnarrayKeys.length; pr++){\n       Qualtrics.SurveyEngine.setEmbeddedData(returnarrayKeys[pr], returnarray[returnarrayKeys[pr]]); \n}\n});\nQualtrics.SurveyEngine.addOnReady(function() {\n\t/* Place your JavaScript here to run when the page is fully displayed */\n});\nQualtrics.SurveyEngine.addOnUnload(function() {\n\t/* Place your JavaScript here to run when the page is unloaded */\n});","DataExportTag":"Q2","QuestionID":"QID2"}},{"SurveyID":"SV_0IZdEq5rOGs2DGu","Element":"SQ","PrimaryAttribute":"QID3","SecondaryAttribute":null,"TertiaryAttribute":null,"Payload":{"QuestionText":"<span>Question 3</span>\n<br /><br />\n<span>Please carefully review the options detailed below, then please answer the questions.</span>\n<br/>\n<br/>\n<span>Which of these choices do you prefer?</span>\n<br />\n<div>\n<br />\n<table class=\"UserTable\">\n<tbody>\n<tr>\n<td>&nbsp;</td>\n<td style=\"text-align: center;\">\n<strong>Choice 1</strong></td>\n<td style=\"text-align: center;\">\n<strong>Choice 2</strong></td>\n</tr>\n<tr>\n<td style='text-align: center;'><strong>${e://Field/F-3-1}</strong></td>\n<td style='text-align: center;'>${e://Field/F-3-1-1}</td>\n<td style='text-align: center;'>${e://Field/F-3-2-1}</td>\n</tr><tr>\n<td style='text-align: center;'><strong>${e://Field/F-3-2}</strong></td>\n<td style='text-align: center;'>${e://Field/F-3-1-2}</td>\n<td style='text-align: center;'>${e://Field/F-3-2-2}</td>\n</tr></tbody>\n</table>\n</div>","QuestionType":"MC","Selector":"SAVR","Choices":{"1":{"Display":"Profile 1"},"2":{"Display":"Profile 2"}},"QuestionJS":"Qualtrics.SurveyEngine.addOnload(function() {\n\t// Code to randomly generate conjoint profiles in a Qualtrics survey\n\n// Terminology clarification: \n// Task = Set of choices presented to respondent in a single screen (i.e. pair of candidates)\n// Profile = Single list of attributes in a given task (i.e. candidate)\n// Attribute = Category characterized by a set of levels (i.e. education level)\n// Level = Value that an attribute can take in a particular choice task (i.e. \"no formal education\")\n\n// Attributes and Levels stored in a 2-dimensional Array \n\n/* Randomize array in-place using Durstenfeld shuffle algorithm */\nfunction shuffleArray(array) {\n    for (var i = array.length - 1; i > 0; i--) {\n        var j = Math.floor(Math.random() * (i + 1));\n        var temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n    return(array);\n}\n\n// Function to generate weighted random numbers\nfunction weighted_randomize(prob_array, at_key)\n{\n\tvar prob_list = prob_array[at_key];\n\t\n\t// Create an array containing cutpoints for randomization\n\tvar cumul_prob = new Array(prob_list.length);\n\tvar cumulative = 0.0;\n\tfor (var i=0;  i < prob_list.length; i++){\n\t\tcumul_prob[i] = cumulative;\n\t\tcumulative = cumulative + parseFloat(prob_list[i]);\n\t}\n\n\t// Generate a uniform random floating point value between 0.0 and 1.0\n\tvar unif_rand = Math.random();\n\n\t// Figure out which integer should be returned\n\tvar outInt = 0;\n\tfor (var k = 0; k < cumul_prob.length; k++){\n\t\tif (cumul_prob[k] <= unif_rand){\n\t\t\toutInt = k + 1;\n\t\t}\n\t}\n\n\treturn(outInt);\n\n}\n                    \n\n\tvar featurearray = {\"check\" : [\"adding\",\"checking\",\"maybe working\"],\"check2\" : [\"checking1\",\"checking2\"]};\n\n\n\tvar restrictionarray = [];\n\n\n\tvar probabilityarray = {};\n\n\t// Indicator for whether weighted randomization should be enabled or not\n\tvar weighted = 0;\n\n\t// K = Number of tasks displayed to the respondent\n\tvar K = 5;\n\n\t// N = Number of profiles displayed in each task\n\tvar N = 2;\n\n\t// num_attributes = Number of Attributes in the Array\n\tvar num_attributes = featurearray.length;\n\n\t// Should duplicate profiles be rejected?\n\tvar noDuplicateProfiles = 0;\n\n\tvar attrconstraintarray = [];\n// Re-randomize the featurearray\n\n// Place the featurearray keys into a new array\nvar featureArrayKeys = Object.keys(featurearray);\n\n// If order randomization constraints exist, drop all of the non-free attributes\nif (attrconstraintarray.length != 0){\n\tfor (const constraints of attrconstraintarray){\n\t\tif (constraints.length > 1){\n\t\t\tfor (var p = 1; p < constraints.length; p++){\n\t\t\t\tif (featureArrayKeys.includes(constraints[p])){\n\t\t\t\t\tvar remkey = featureArrayKeys.indexOf(constraints[p]);\n                    featureArrayKeys.splice(remkey, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} \n\n// Re-randomize the featurearray keys\nfeatureArrayKeys = shuffleArray(featureArrayKeys);\n\n// Re-insert the non-free attributes constrained by attrconstraintarray\nif (attrconstraintarray.length != 0){\n\tfor (const constraints of attrconstraintarray){\n\t\tif (constraints.length > 1){\n\t\t\tvar insertloc = constraints[0];\n\t\t\tif (featureArrayKeys.includes(insertloc)){\n\t\t\t\tvar insert_block = [];\n\t\t\t\tfor (var p = 1; p < constraints.length; p++){\n          insert_block.push(constraints[p]);\n\t\t\t\t}\n\t\t\t\tvar begin_index = featureArrayKeys.indexOf(insertloc);\n\t\t\t\tfeatureArrayKeys.splice(begin_index+1, 0, ...insert_block);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// Re-generate the new featurearray - label it featureArrayNew\nvar featureArrayNew = {};\nfor (var h = 0; h < featureArrayKeys.length; h++){\n    featureArrayNew[featureArrayKeys[h]] = featurearray[featureArrayKeys[h]];        \n}\n\n\n// Initialize the array returned to the user\n// Naming Convention\n// Level Name: F-[task number]-[profile number]-[attribute number]\n// Attribute Name: F-[task number]-[attribute number]\n// Example: F-1-3-2, Returns the level corresponding to Task 1, Profile 3, Attribute 2 \n// F-3-3, Returns the attribute name corresponding to Task 3, Attribute 3\n\nvar returnarray = {};\n\n// For each task p\nfor(var p = 1; p <= K; p++){\n\n\t// For each profile i\n\tfor(var i = 1; i <= N; i++){\n\n\t\t// Repeat until non-restricted profile generated\n\t\tvar complete = false;\n\n\t\twhile (complete == false){\n\n\t\t\t// Create a count for attributes to be incremented in the next loop\n\t\t\tvar attr = 0;\n\t\t\t\n\t\t\t// Create a dictionary to hold profile's attributes\n\t\t\tvar profile_dict = {};\n\n\t\t\t// For each attribute attribute and level array levels in task p\n\t\t\tfor(var q = 0; q < featureArrayKeys.length; q++){\n\t\t\t\t// Get Attribute name\n\t\t\t\tvar attr_name = featureArrayKeys[q];\n\t\t\t\t\t\n\t\t\t\t// Increment attribute count\n\t\t\t\tattr = attr + 1;\n\t\n\t\t\t\t// Create key for attribute name\n\t\t\t\tvar attr_key = \"F-\" + p + \"-\" + attr;\n\t\n                // Store attribute name in returnarray\n                returnarray[attr_key] = attr_name;\n\n\t\t\t\t// Get length of levels array\n\t\t\t\tvar num_levels = featureArrayNew[attr_name].length;\n\n\t\t\t\t// Randomly select one of the level indices\n\t\t\t\tif (weighted == 1){\n\t\t\t\t\tvar level_index = weighted_randomize(probabilityarray, attr_name) - 1;\n\n\t\t\t\t}else{\n\t\t\t\t\tvar level_index = Math.floor(Math.random() * num_levels);\n\t\t\t\t}\t\n\n\t\t\t\t// Pull out the selected level\n\t\t\t\tvar chosen_level = featureArrayNew[attr_name][level_index];\n\t\t\t\t\n\t\t\t\t// Store selected level in profileDict\n\t\t\t\tprofile_dict[attr_name] = chosen_level;\n\t\n\t\t\t\t// Create key for level in returnarray\n\t\t\t\tvar level_key = \"F-\" + p + \"-\" + i + \"-\" + attr;\n\t\n\t\t\t\t// Store selected level in returnarray\n\t\t\t\treturnarray[level_key] = chosen_level;\n\n\t\t\t}\n\n            var clear = true;\n            \n            // Cycle through restrictions to confirm/reject profile\n            if (restrictionarray.length != 0){\n                for (var v = 0; v < restrictionarray.length; v++){\n                    var falsevar = 1;\n                    for (var mp = 0; mp < restrictionarray[v].length; mp++){\n                        if (profile_dict[restrictionarray[v][mp][0]] == restrictionarray[v][mp][1]){\n                            falsevar = falsevar*1;\n                        }else{\n                            falsevar = falsevar*0;\n                        }\t\t\t\t\t\t\t\n                    }\n                    if (falsevar == 1){\n                        clear = false;\n                    }\n                }\n            }\n                            \n            // If we're throwing out duplicates\n            if (noDuplicateProfiles == true){\n                // Cycle through all previous profiles to confirm no identical profiles\n                if (i > 1){    \n                    // For each previous profile\n                    for(var z = 1; z < i; z++){\n    \t\t\t\t\t\n                        // Start by assuming it's the same\n                        var identical = true;\n    \t\t\t\t\t\n                        // Create a count for attributes to be incremented in the next loop\n                        var attrTemp = 0;\n    \t\t\t\t\t\n                        // For each attribute attribute and level array levels in task p\n                        for(var qz = 0; qz < featureArrayKeys.length; qz++){\n    \t\t\t\t\t\t\n                            // Increment attribute count\n                            attrTemp = attrTemp + 1;\n    \n                            // Create keys \n                            var level_key_profile = \"F-\" + p + \"-\" + i + \"-\" + attrTemp;\n                            var level_key_check = \"F-\" + p + \"-\" + z + \"-\" + attrTemp;\n    \t\t\t\t\t\t\n                            // If attributes are different, declare not identical\n                            if (returnarray[level_key_profile] != returnarray[level_key_check]){\n                                identical = false;\n                            }\n                        }\n                        // If we detect an identical profile, reject\n                        if (identical == true){\n                            clear = false;\n                        }\n                    }                \n                }\n            }\n            complete = clear;\n        }\n    }\n}\n                            \n// Write returnarray to Qualtrics\n\nvar returnarrayKeys = Object.keys(returnarray);\n\nfor (var pr = 0; pr < returnarrayKeys.length; pr++){\n       Qualtrics.SurveyEngine.setEmbeddedData(returnarrayKeys[pr], returnarray[returnarrayKeys[pr]]); \n}\n});\nQualtrics.SurveyEngine.addOnReady(function() {\n\t/* Place your JavaScript here to run when the page is fully displayed */\n});\nQualtrics.SurveyEngine.addOnUnload(function() {\n\t/* Place your JavaScript here to run when the page is unloaded */\n});","DataExportTag":"Q3","QuestionID":"QID3"}},{"SurveyID":"SV_0IZdEq5rOGs2DGu","Element":"SQ","PrimaryAttribute":"QID4","SecondaryAttribute":null,"TertiaryAttribute":null,"Payload":{"QuestionText":"<span>Question 4</span>\n<br /><br />\n<span>Please carefully review the options detailed below, then please answer the questions.</span>\n<br/>\n<br/>\n<span>Which of these choices do you prefer?</span>\n<br />\n<div>\n<br />\n<table class=\"UserTable\">\n<tbody>\n<tr>\n<td>&nbsp;</td>\n<td style=\"text-align: center;\">\n<strong>Choice 1</strong></td>\n<td style=\"text-align: center;\">\n<strong>Choice 2</strong></td>\n</tr>\n<tr>\n<td style='text-align: center;'><strong>${e://Field/F-4-1}</strong></td>\n<td style='text-align: center;'>${e://Field/F-4-1-1}</td>\n<td style='text-align: center;'>${e://Field/F-4-2-1}</td>\n</tr><tr>\n<td style='text-align: center;'><strong>${e://Field/F-4-2}</strong></td>\n<td style='text-align: center;'>${e://Field/F-4-1-2}</td>\n<td style='text-align: center;'>${e://Field/F-4-2-2}</td>\n</tr></tbody>\n</table>\n</div>","QuestionType":"MC","Selector":"SAVR","Choices":{"1":{"Display":"Profile 1"},"2":{"Display":"Profile 2"}},"QuestionJS":"Qualtrics.SurveyEngine.addOnload(function() {\n\t// Code to randomly generate conjoint profiles in a Qualtrics survey\n\n// Terminology clarification: \n// Task = Set of choices presented to respondent in a single screen (i.e. pair of candidates)\n// Profile = Single list of attributes in a given task (i.e. candidate)\n// Attribute = Category characterized by a set of levels (i.e. education level)\n// Level = Value that an attribute can take in a particular choice task (i.e. \"no formal education\")\n\n// Attributes and Levels stored in a 2-dimensional Array \n\n/* Randomize array in-place using Durstenfeld shuffle algorithm */\nfunction shuffleArray(array) {\n    for (var i = array.length - 1; i > 0; i--) {\n        var j = Math.floor(Math.random() * (i + 1));\n        var temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n    return(array);\n}\n\n// Function to generate weighted random numbers\nfunction weighted_randomize(prob_array, at_key)\n{\n\tvar prob_list = prob_array[at_key];\n\t\n\t// Create an array containing cutpoints for randomization\n\tvar cumul_prob = new Array(prob_list.length);\n\tvar cumulative = 0.0;\n\tfor (var i=0;  i < prob_list.length; i++){\n\t\tcumul_prob[i] = cumulative;\n\t\tcumulative = cumulative + parseFloat(prob_list[i]);\n\t}\n\n\t// Generate a uniform random floating point value between 0.0 and 1.0\n\tvar unif_rand = Math.random();\n\n\t// Figure out which integer should be returned\n\tvar outInt = 0;\n\tfor (var k = 0; k < cumul_prob.length; k++){\n\t\tif (cumul_prob[k] <= unif_rand){\n\t\t\toutInt = k + 1;\n\t\t}\n\t}\n\n\treturn(outInt);\n\n}\n                    \n\n\tvar featurearray = {\"check\" : [\"adding\",\"checking\",\"maybe working\"],\"check2\" : [\"checking1\",\"checking2\"]};\n\n\n\tvar restrictionarray = [];\n\n\n\tvar probabilityarray = {};\n\n\t// Indicator for whether weighted randomization should be enabled or not\n\tvar weighted = 0;\n\n\t// K = Number of tasks displayed to the respondent\n\tvar K = 5;\n\n\t// N = Number of profiles displayed in each task\n\tvar N = 2;\n\n\t// num_attributes = Number of Attributes in the Array\n\tvar num_attributes = featurearray.length;\n\n\t// Should duplicate profiles be rejected?\n\tvar noDuplicateProfiles = 0;\n\n\tvar attrconstraintarray = [];\n// Re-randomize the featurearray\n\n// Place the featurearray keys into a new array\nvar featureArrayKeys = Object.keys(featurearray);\n\n// If order randomization constraints exist, drop all of the non-free attributes\nif (attrconstraintarray.length != 0){\n\tfor (const constraints of attrconstraintarray){\n\t\tif (constraints.length > 1){\n\t\t\tfor (var p = 1; p < constraints.length; p++){\n\t\t\t\tif (featureArrayKeys.includes(constraints[p])){\n\t\t\t\t\tvar remkey = featureArrayKeys.indexOf(constraints[p]);\n                    featureArrayKeys.splice(remkey, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} \n\n// Re-randomize the featurearray keys\nfeatureArrayKeys = shuffleArray(featureArrayKeys);\n\n// Re-insert the non-free attributes constrained by attrconstraintarray\nif (attrconstraintarray.length != 0){\n\tfor (const constraints of attrconstraintarray){\n\t\tif (constraints.length > 1){\n\t\t\tvar insertloc = constraints[0];\n\t\t\tif (featureArrayKeys.includes(insertloc)){\n\t\t\t\tvar insert_block = [];\n\t\t\t\tfor (var p = 1; p < constraints.length; p++){\n          insert_block.push(constraints[p]);\n\t\t\t\t}\n\t\t\t\tvar begin_index = featureArrayKeys.indexOf(insertloc);\n\t\t\t\tfeatureArrayKeys.splice(begin_index+1, 0, ...insert_block);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// Re-generate the new featurearray - label it featureArrayNew\nvar featureArrayNew = {};\nfor (var h = 0; h < featureArrayKeys.length; h++){\n    featureArrayNew[featureArrayKeys[h]] = featurearray[featureArrayKeys[h]];        \n}\n\n\n// Initialize the array returned to the user\n// Naming Convention\n// Level Name: F-[task number]-[profile number]-[attribute number]\n// Attribute Name: F-[task number]-[attribute number]\n// Example: F-1-3-2, Returns the level corresponding to Task 1, Profile 3, Attribute 2 \n// F-3-3, Returns the attribute name corresponding to Task 3, Attribute 3\n\nvar returnarray = {};\n\n// For each task p\nfor(var p = 1; p <= K; p++){\n\n\t// For each profile i\n\tfor(var i = 1; i <= N; i++){\n\n\t\t// Repeat until non-restricted profile generated\n\t\tvar complete = false;\n\n\t\twhile (complete == false){\n\n\t\t\t// Create a count for attributes to be incremented in the next loop\n\t\t\tvar attr = 0;\n\t\t\t\n\t\t\t// Create a dictionary to hold profile's attributes\n\t\t\tvar profile_dict = {};\n\n\t\t\t// For each attribute attribute and level array levels in task p\n\t\t\tfor(var q = 0; q < featureArrayKeys.length; q++){\n\t\t\t\t// Get Attribute name\n\t\t\t\tvar attr_name = featureArrayKeys[q];\n\t\t\t\t\t\n\t\t\t\t// Increment attribute count\n\t\t\t\tattr = attr + 1;\n\t\n\t\t\t\t// Create key for attribute name\n\t\t\t\tvar attr_key = \"F-\" + p + \"-\" + attr;\n\t\n                // Store attribute name in returnarray\n                returnarray[attr_key] = attr_name;\n\n\t\t\t\t// Get length of levels array\n\t\t\t\tvar num_levels = featureArrayNew[attr_name].length;\n\n\t\t\t\t// Randomly select one of the level indices\n\t\t\t\tif (weighted == 1){\n\t\t\t\t\tvar level_index = weighted_randomize(probabilityarray, attr_name) - 1;\n\n\t\t\t\t}else{\n\t\t\t\t\tvar level_index = Math.floor(Math.random() * num_levels);\n\t\t\t\t}\t\n\n\t\t\t\t// Pull out the selected level\n\t\t\t\tvar chosen_level = featureArrayNew[attr_name][level_index];\n\t\t\t\t\n\t\t\t\t// Store selected level in profileDict\n\t\t\t\tprofile_dict[attr_name] = chosen_level;\n\t\n\t\t\t\t// Create key for level in returnarray\n\t\t\t\tvar level_key = \"F-\" + p + \"-\" + i + \"-\" + attr;\n\t\n\t\t\t\t// Store selected level in returnarray\n\t\t\t\treturnarray[level_key] = chosen_level;\n\n\t\t\t}\n\n            var clear = true;\n            \n            // Cycle through restrictions to confirm/reject profile\n            if (restrictionarray.length != 0){\n                for (var v = 0; v < restrictionarray.length; v++){\n                    var falsevar = 1;\n                    for (var mp = 0; mp < restrictionarray[v].length; mp++){\n                        if (profile_dict[restrictionarray[v][mp][0]] == restrictionarray[v][mp][1]){\n                            falsevar = falsevar*1;\n                        }else{\n                            falsevar = falsevar*0;\n                        }\t\t\t\t\t\t\t\n                    }\n                    if (falsevar == 1){\n                        clear = false;\n                    }\n                }\n            }\n                            \n            // If we're throwing out duplicates\n            if (noDuplicateProfiles == true){\n                // Cycle through all previous profiles to confirm no identical profiles\n                if (i > 1){    \n                    // For each previous profile\n                    for(var z = 1; z < i; z++){\n    \t\t\t\t\t\n                        // Start by assuming it's the same\n                        var identical = true;\n    \t\t\t\t\t\n                        // Create a count for attributes to be incremented in the next loop\n                        var attrTemp = 0;\n    \t\t\t\t\t\n                        // For each attribute attribute and level array levels in task p\n                        for(var qz = 0; qz < featureArrayKeys.length; qz++){\n    \t\t\t\t\t\t\n                            // Increment attribute count\n                            attrTemp = attrTemp + 1;\n    \n                            // Create keys \n                            var level_key_profile = \"F-\" + p + \"-\" + i + \"-\" + attrTemp;\n                            var level_key_check = \"F-\" + p + \"-\" + z + \"-\" + attrTemp;\n    \t\t\t\t\t\t\n                            // If attributes are different, declare not identical\n                            if (returnarray[level_key_profile] != returnarray[level_key_check]){\n                                identical = false;\n                            }\n                        }\n                        // If we detect an identical profile, reject\n                        if (identical == true){\n                            clear = false;\n                        }\n                    }                \n                }\n            }\n            complete = clear;\n        }\n    }\n}\n                            \n// Write returnarray to Qualtrics\n\nvar returnarrayKeys = Object.keys(returnarray);\n\nfor (var pr = 0; pr < returnarrayKeys.length; pr++){\n       Qualtrics.SurveyEngine.setEmbeddedData(returnarrayKeys[pr], returnarray[returnarrayKeys[pr]]); \n}\n});\nQualtrics.SurveyEngine.addOnReady(function() {\n\t/* Place your JavaScript here to run when the page is fully displayed */\n});\nQualtrics.SurveyEngine.addOnUnload(function() {\n\t/* Place your JavaScript here to run when the page is unloaded */\n});","DataExportTag":"Q4","QuestionID":"QID4"}},{"SurveyID":"SV_0IZdEq5rOGs2DGu","Element":"SQ","PrimaryAttribute":"QID5","SecondaryAttribute":null,"TertiaryAttribute":null,"Payload":{"QuestionText":"<span>Question 5</span>\n<br /><br />\n<span>Please carefully review the options detailed below, then please answer the questions.</span>\n<br/>\n<br/>\n<span>Which of these choices do you prefer?</span>\n<br />\n<div>\n<br />\n<table class=\"UserTable\">\n<tbody>\n<tr>\n<td>&nbsp;</td>\n<td style=\"text-align: center;\">\n<strong>Choice 1</strong></td>\n<td style=\"text-align: center;\">\n<strong>Choice 2</strong></td>\n</tr>\n<tr>\n<td style='text-align: center;'><strong>${e://Field/F-5-1}</strong></td>\n<td style='text-align: center;'>${e://Field/F-5-1-1}</td>\n<td style='text-align: center;'>${e://Field/F-5-2-1}</td>\n</tr><tr>\n<td style='text-align: center;'><strong>${e://Field/F-5-2}</strong></td>\n<td style='text-align: center;'>${e://Field/F-5-1-2}</td>\n<td style='text-align: center;'>${e://Field/F-5-2-2}</td>\n</tr></tbody>\n</table>\n</div>","QuestionType":"MC","Selector":"SAVR","Choices":{"1":{"Display":"Profile 1"},"2":{"Display":"Profile 2"}},"QuestionJS":"Qualtrics.SurveyEngine.addOnload(function() {\n\t// Code to randomly generate conjoint profiles in a Qualtrics survey\n\n// Terminology clarification: \n// Task = Set of choices presented to respondent in a single screen (i.e. pair of candidates)\n// Profile = Single list of attributes in a given task (i.e. candidate)\n// Attribute = Category characterized by a set of levels (i.e. education level)\n// Level = Value that an attribute can take in a particular choice task (i.e. \"no formal education\")\n\n// Attributes and Levels stored in a 2-dimensional Array \n\n/* Randomize array in-place using Durstenfeld shuffle algorithm */\nfunction shuffleArray(array) {\n    for (var i = array.length - 1; i > 0; i--) {\n        var j = Math.floor(Math.random() * (i + 1));\n        var temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n    return(array);\n}\n\n// Function to generate weighted random numbers\nfunction weighted_randomize(prob_array, at_key)\n{\n\tvar prob_list = prob_array[at_key];\n\t\n\t// Create an array containing cutpoints for randomization\n\tvar cumul_prob = new Array(prob_list.length);\n\tvar cumulative = 0.0;\n\tfor (var i=0;  i < prob_list.length; i++){\n\t\tcumul_prob[i] = cumulative;\n\t\tcumulative = cumulative + parseFloat(prob_list[i]);\n\t}\n\n\t// Generate a uniform random floating point value between 0.0 and 1.0\n\tvar unif_rand = Math.random();\n\n\t// Figure out which integer should be returned\n\tvar outInt = 0;\n\tfor (var k = 0; k < cumul_prob.length; k++){\n\t\tif (cumul_prob[k] <= unif_rand){\n\t\t\toutInt = k + 1;\n\t\t}\n\t}\n\n\treturn(outInt);\n\n}\n                    \n\n\tvar featurearray = {\"check\" : [\"adding\",\"checking\",\"maybe working\"],\"check2\" : [\"checking1\",\"checking2\"]};\n\n\n\tvar restrictionarray = [];\n\n\n\tvar probabilityarray = {};\n\n\t// Indicator for whether weighted randomization should be enabled or not\n\tvar weighted = 0;\n\n\t// K = Number of tasks displayed to the respondent\n\tvar K = 5;\n\n\t// N = Number of profiles displayed in each task\n\tvar N = 2;\n\n\t// num_attributes = Number of Attributes in the Array\n\tvar num_attributes = featurearray.length;\n\n\t// Should duplicate profiles be rejected?\n\tvar noDuplicateProfiles = 0;\n\n\tvar attrconstraintarray = [];\n// Re-randomize the featurearray\n\n// Place the featurearray keys into a new array\nvar featureArrayKeys = Object.keys(featurearray);\n\n// If order randomization constraints exist, drop all of the non-free attributes\nif (attrconstraintarray.length != 0){\n\tfor (const constraints of attrconstraintarray){\n\t\tif (constraints.length > 1){\n\t\t\tfor (var p = 1; p < constraints.length; p++){\n\t\t\t\tif (featureArrayKeys.includes(constraints[p])){\n\t\t\t\t\tvar remkey = featureArrayKeys.indexOf(constraints[p]);\n                    featureArrayKeys.splice(remkey, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} \n\n// Re-randomize the featurearray keys\nfeatureArrayKeys = shuffleArray(featureArrayKeys);\n\n// Re-insert the non-free attributes constrained by attrconstraintarray\nif (attrconstraintarray.length != 0){\n\tfor (const constraints of attrconstraintarray){\n\t\tif (constraints.length > 1){\n\t\t\tvar insertloc = constraints[0];\n\t\t\tif (featureArrayKeys.includes(insertloc)){\n\t\t\t\tvar insert_block = [];\n\t\t\t\tfor (var p = 1; p < constraints.length; p++){\n          insert_block.push(constraints[p]);\n\t\t\t\t}\n\t\t\t\tvar begin_index = featureArrayKeys.indexOf(insertloc);\n\t\t\t\tfeatureArrayKeys.splice(begin_index+1, 0, ...insert_block);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// Re-generate the new featurearray - label it featureArrayNew\nvar featureArrayNew = {};\nfor (var h = 0; h < featureArrayKeys.length; h++){\n    featureArrayNew[featureArrayKeys[h]] = featurearray[featureArrayKeys[h]];        \n}\n\n\n// Initialize the array returned to the user\n// Naming Convention\n// Level Name: F-[task number]-[profile number]-[attribute number]\n// Attribute Name: F-[task number]-[attribute number]\n// Example: F-1-3-2, Returns the level corresponding to Task 1, Profile 3, Attribute 2 \n// F-3-3, Returns the attribute name corresponding to Task 3, Attribute 3\n\nvar returnarray = {};\n\n// For each task p\nfor(var p = 1; p <= K; p++){\n\n\t// For each profile i\n\tfor(var i = 1; i <= N; i++){\n\n\t\t// Repeat until non-restricted profile generated\n\t\tvar complete = false;\n\n\t\twhile (complete == false){\n\n\t\t\t// Create a count for attributes to be incremented in the next loop\n\t\t\tvar attr = 0;\n\t\t\t\n\t\t\t// Create a dictionary to hold profile's attributes\n\t\t\tvar profile_dict = {};\n\n\t\t\t// For each attribute attribute and level array levels in task p\n\t\t\tfor(var q = 0; q < featureArrayKeys.length; q++){\n\t\t\t\t// Get Attribute name\n\t\t\t\tvar attr_name = featureArrayKeys[q];\n\t\t\t\t\t\n\t\t\t\t// Increment attribute count\n\t\t\t\tattr = attr + 1;\n\t\n\t\t\t\t// Create key for attribute name\n\t\t\t\tvar attr_key = \"F-\" + p + \"-\" + attr;\n\t\n                // Store attribute name in returnarray\n                returnarray[attr_key] = attr_name;\n\n\t\t\t\t// Get length of levels array\n\t\t\t\tvar num_levels = featureArrayNew[attr_name].length;\n\n\t\t\t\t// Randomly select one of the level indices\n\t\t\t\tif (weighted == 1){\n\t\t\t\t\tvar level_index = weighted_randomize(probabilityarray, attr_name) - 1;\n\n\t\t\t\t}else{\n\t\t\t\t\tvar level_index = Math.floor(Math.random() * num_levels);\n\t\t\t\t}\t\n\n\t\t\t\t// Pull out the selected level\n\t\t\t\tvar chosen_level = featureArrayNew[attr_name][level_index];\n\t\t\t\t\n\t\t\t\t// Store selected level in profileDict\n\t\t\t\tprofile_dict[attr_name] = chosen_level;\n\t\n\t\t\t\t// Create key for level in returnarray\n\t\t\t\tvar level_key = \"F-\" + p + \"-\" + i + \"-\" + attr;\n\t\n\t\t\t\t// Store selected level in returnarray\n\t\t\t\treturnarray[level_key] = chosen_level;\n\n\t\t\t}\n\n            var clear = true;\n            \n            // Cycle through restrictions to confirm/reject profile\n            if (restrictionarray.length != 0){\n                for (var v = 0; v < restrictionarray.length; v++){\n                    var falsevar = 1;\n                    for (var mp = 0; mp < restrictionarray[v].length; mp++){\n                        if (profile_dict[restrictionarray[v][mp][0]] == restrictionarray[v][mp][1]){\n                            falsevar = falsevar*1;\n                        }else{\n                            falsevar = falsevar*0;\n                        }\t\t\t\t\t\t\t\n                    }\n                    if (falsevar == 1){\n                        clear = false;\n                    }\n                }\n            }\n                            \n            // If we're throwing out duplicates\n            if (noDuplicateProfiles == true){\n                // Cycle through all previous profiles to confirm no identical profiles\n                if (i > 1){    \n                    // For each previous profile\n                    for(var z = 1; z < i; z++){\n    \t\t\t\t\t\n                        // Start by assuming it's the same\n                        var identical = true;\n    \t\t\t\t\t\n                        // Create a count for attributes to be incremented in the next loop\n                        var attrTemp = 0;\n    \t\t\t\t\t\n                        // For each attribute attribute and level array levels in task p\n                        for(var qz = 0; qz < featureArrayKeys.length; qz++){\n    \t\t\t\t\t\t\n                            // Increment attribute count\n                            attrTemp = attrTemp + 1;\n    \n                            // Create keys \n                            var level_key_profile = \"F-\" + p + \"-\" + i + \"-\" + attrTemp;\n                            var level_key_check = \"F-\" + p + \"-\" + z + \"-\" + attrTemp;\n    \t\t\t\t\t\t\n                            // If attributes are different, declare not identical\n                            if (returnarray[level_key_profile] != returnarray[level_key_check]){\n                                identical = false;\n                            }\n                        }\n                        // If we detect an identical profile, reject\n                        if (identical == true){\n                            clear = false;\n                        }\n                    }                \n                }\n            }\n            complete = clear;\n        }\n    }\n}\n                            \n// Write returnarray to Qualtrics\n\nvar returnarrayKeys = Object.keys(returnarray);\n\nfor (var pr = 0; pr < returnarrayKeys.length; pr++){\n       Qualtrics.SurveyEngine.setEmbeddedData(returnarrayKeys[pr], returnarray[returnarrayKeys[pr]]); \n}\n});\nQualtrics.SurveyEngine.addOnReady(function() {\n\t/* Place your JavaScript here to run when the page is fully displayed */\n});\nQualtrics.SurveyEngine.addOnUnload(function() {\n\t/* Place your JavaScript here to run when the page is unloaded */\n});","DataExportTag":"Q5","QuestionID":"QID5"}},{"SurveyID":"SV_0IZdEq5rOGs2DGu","Element":"SCO","PrimaryAttribute":"Scoring","SecondaryAttribute":null,"TertiaryAttribute":null,"Payload":{"ScoringCategories":[],"ScoringCategoryGroups":[],"ScoringSummaryCategory":null,"ScoringSummaryAfterQuestions":0,"ScoringSummaryAfterSurvey":0,"DefaultScoringCategory":null,"AutoScoringCategory":null}},{"SurveyID":"SV_0IZdEq5rOGs2DGu","Element":"PROJ","PrimaryAttribute":"CORE","SecondaryAttribute":null,"TertiaryAttribute":"1.1.0","Payload":{"ProjectCategory":"CORE","SchemaVersion":"1.1.0"}},{"SurveyID":"SV_0IZdEq5rOGs2DGu","Element":"QC","PrimaryAttribute":"Survey Question Count","SecondaryAttribute":"5","TertiaryAttribute":null,"Payload":null},{"SurveyID":"SV_0IZdEq5rOGs2DGu","Element":"RS","PrimaryAttribute":"RS_bw5sVeqmQg6y246","SecondaryAttribute":"  ","TertiaryAttribute":null,"Payload":null}]}}